"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Portal = void 0;
const definitions_1 = require("./definitions");
const protocol_1 = require("./protocol/protocol");
const DataTypeMap_1 = require("./DataTypeMap");
const common_1 = require("./common");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('pgc:portal');
class Portal {
    constructor(statement, name) {
        this._columnFormat = definitions_1.DEFAULT_COLUMN_FORMAT;
        this._statement = statement;
        this._name = name;
        debug('[%s] constructor', this.name);
    }
    get connection() {
        return this._statement.connection;
    }
    get name() {
        return this._name;
    }
    async bind(params, queryOptions) {
        debug('[%s] bind', this.name);
        const intoCon = (0, common_1.getIntlConnection)(this.connection);
        intoCon.ref();
        try {
            const socket = intoCon.socket;
            this._columnFormat = queryOptions.columnFormat != null ?
                queryOptions.columnFormat : protocol_1.Protocol.DataFormat.binary;
            socket.sendBindMessage({
                typeMap: queryOptions.typeMap || DataTypeMap_1.GlobalTypeMap,
                statement: this._statement.name,
                portal: this.name,
                paramTypes: this._statement.paramTypes,
                params,
                queryOptions
            });
            socket.sendFlushMessage();
            return await socket.capture(async (code, msg, done) => {
                switch (code) {
                    case protocol_1.Protocol.BackendMessageCode.BindComplete:
                        done();
                        break;
                    case protocol_1.Protocol.BackendMessageCode.NoticeResponse:
                        break;
                    default:
                        done(new Error(`Server returned unexpected response message (${String.fromCharCode(code)})`));
                }
            });
        }
        finally {
            intoCon.unref();
        }
    }
    async retrieveFields() {
        debug('[%s] retrieveFields', this.name);
        const intoCon = (0, common_1.getIntlConnection)(this.connection);
        intoCon.ref();
        try {
            const socket = intoCon.socket;
            socket.sendDescribeMessage({ type: 'P', name: this.name });
            socket.sendFlushMessage();
            return await socket.capture(async (code, msg, done) => {
                switch (code) {
                    case protocol_1.Protocol.BackendMessageCode.NoticeResponse:
                        break;
                    case protocol_1.Protocol.BackendMessageCode.NoData:
                        done();
                        break;
                    case protocol_1.Protocol.BackendMessageCode.RowDescription:
                        done(undefined, msg.fields);
                        break;
                    default:
                        done(new Error(`Server returned unexpected response message (${String.fromCharCode(code)})`));
                }
            });
        }
        finally {
            intoCon.unref();
        }
    }
    async execute(fetchCount) {
        debug('[%s] execute', this.name);
        const intoCon = (0, common_1.getIntlConnection)(this.connection);
        intoCon.ref();
        try {
            const socket = intoCon.socket;
            socket.sendExecuteMessage({ portal: this.name, fetchCount: fetchCount || 100 });
            socket.sendFlushMessage();
            const rows = [];
            return await socket.capture(async (code, msg, done) => {
                switch (code) {
                    case protocol_1.Protocol.BackendMessageCode.NoticeResponse:
                        break;
                    case protocol_1.Protocol.BackendMessageCode.NoData:
                        done(undefined, { code });
                        break;
                    case protocol_1.Protocol.BackendMessageCode.DataRow:
                        if (Array.isArray(this._columnFormat)) {
                            rows.push(msg.columns.map((buf, i) => this._columnFormat[i] === protocol_1.Protocol.DataFormat.text ?
                                buf.toString('utf8') : buf));
                        }
                        else if (this._columnFormat === protocol_1.Protocol.DataFormat.binary)
                            rows.push(msg.columns);
                        else
                            rows.push(msg.columns.map((buf) => buf.toString('utf8')));
                        break;
                    case protocol_1.Protocol.BackendMessageCode.PortalSuspended:
                        done(undefined, { code, rows });
                        break;
                    case protocol_1.Protocol.BackendMessageCode.CommandComplete:
                        done(undefined, {
                            code, rows,
                            command: msg.command,
                            rowCount: msg.rowCount
                        });
                        break;
                    default:
                        done(new Error(`Server returned unexpected response message (${String.fromCharCode(code)})`));
                }
            });
        }
        finally {
            intoCon.unref();
        }
    }
    async close() {
        debug('[%s] close', this.name);
        const intoCon = (0, common_1.getIntlConnection)(this.connection);
        intoCon.ref();
        try {
            const socket = intoCon.socket;
            socket.sendCloseMessage({ type: 'P', name: this.name });
            socket.sendSyncMessage();
            return await socket.capture(async (code, msg, done) => {
                switch (code) {
                    case protocol_1.Protocol.BackendMessageCode.NoticeResponse:
                        break;
                    case protocol_1.Protocol.BackendMessageCode.CloseComplete:
                        break;
                    case protocol_1.Protocol.BackendMessageCode.ReadyForQuery:
                        intoCon.transactionStatus = msg.status;
                        done();
                        break;
                    default:
                        done(new Error(`Server returned unexpected response message (${String.fromCharCode(code)})`));
                }
            });
        }
        finally {
            intoCon.unref();
        }
    }
}
exports.Portal = Portal;
