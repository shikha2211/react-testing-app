"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntlConnection = void 0;
const putil_taskqueue_1 = __importDefault(require("putil-taskqueue"));
const PgSocket_1 = require("./protocol/PgSocket");
const SafeEventEmitter_1 = require("./SafeEventEmitter");
const definitions_1 = require("./definitions");
const connection_config_1 = require("./util/connection-config");
const protocol_1 = require("./protocol/protocol");
const DataTypeMap_1 = require("./DataTypeMap");
const common_1 = require("./common");
const escape_literal_1 = require("./util/escape-literal");
var DataFormat = protocol_1.Protocol.DataFormat;
const putil_varhelpers_1 = require("putil-varhelpers");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('pgc:intlcon');
class IntlConnection extends SafeEventEmitter_1.SafeEventEmitter {
    constructor(config) {
        super();
        this._refCount = 0;
        this.transactionStatus = 'I';
        this.statementQueue = new putil_taskqueue_1.default();
        this._config = Object.freeze((0, connection_config_1.getConnectionConfig)(config));
        this.socket = new PgSocket_1.PgSocket(this._config);
        this.socket.on('error', (err) => this._onError(err));
        this.socket.on('close', () => this.emit('close'));
        this.socket.on('connecting', () => this.emit('connecting'));
        this._onErrorSavePoint = 'SP_' + (Math.round(Math.random() * 100000000));
    }
    get config() {
        return this._config;
    }
    get inTransaction() {
        return this.transactionStatus === 'T' || this.transactionStatus === 'E';
    }
    get state() {
        return this.socket.state;
    }
    get refCount() {
        return this._refCount;
    }
    get processID() {
        return this.socket.processID;
    }
    get secretKey() {
        return this.socket.secretKey;
    }
    get sessionParameters() {
        return this.socket.sessionParameters;
    }
    async connect() {
        if (this.socket.state === definitions_1.ConnectionState.READY)
            return;
        debug('connecting');
        await new Promise((resolve, reject) => {
            const handleConnectError = (err) => reject(err);
            this.socket.once('ready', () => {
                this.socket.removeListener('error', handleConnectError);
                resolve();
            });
            this.socket.once('error', handleConnectError);
            this.socket.connect();
        });
        let startupCommand = '';
        if (this.config.schema)
            startupCommand += 'SET search_path = ' + (0, escape_literal_1.escapeLiteral)(this.config.schema) + ';';
        if (this.config.timezone)
            startupCommand += 'SET timezone TO ' + (0, escape_literal_1.escapeLiteral)(this.config.timezone) + ';';
        if (startupCommand)
            await this.execute(startupCommand, { autoCommit: true });
        debug('[%s] ready', this.processID);
        this.emit('ready');
    }
    async close() {
        if (this.state === definitions_1.ConnectionState.CLOSED)
            return;
        debug('[%s] closing', this.processID);
        this.statementQueue.clear();
        return new Promise(resolve => {
            if (this.socket.state === definitions_1.ConnectionState.CLOSED)
                return;
            this.socket.once('close', resolve);
            this.socket.sendTerminateMessage(() => {
                this.socket.close();
                debug('[%s] closed', this.processID);
                this.emit('close');
            });
        });
    }
    async execute(sql, options, cb) {
        this.assertConnected();
        return this.statementQueue.enqueue(async () => {
            const transactionCommand = sql.match(/^(\bBEGIN\b|\bCOMMIT\b|\bROLLBACK|SAVEPOINT|RELEASE\b)/i);
            let beginFirst = false;
            let commitLast = false;
            if (!transactionCommand) {
                if (!this.inTransaction &&
                    ((options === null || options === void 0 ? void 0 : options.autoCommit) != null ? options === null || options === void 0 ? void 0 : options.autoCommit : this.config.autoCommit) === false) {
                    beginFirst = true;
                }
                if (this.inTransaction && (options === null || options === void 0 ? void 0 : options.autoCommit))
                    commitLast = true;
            }
            if (beginFirst)
                await this._execute('BEGIN');
            const onErrorRollback = !transactionCommand &&
                ((options === null || options === void 0 ? void 0 : options.onErrorRollback) != null ? options.onErrorRollback :
                    (0, putil_varhelpers_1.coerceToBoolean)(this.config.onErrorRollback, true));
            if (this.inTransaction && onErrorRollback)
                await this._execute('SAVEPOINT ' + this._onErrorSavePoint);
            try {
                const result = await this._execute(sql, options, cb);
                if (commitLast)
                    await this._execute('COMMIT');
                else if (this.inTransaction && onErrorRollback)
                    await this._execute('RELEASE ' + this._onErrorSavePoint + ';');
                return result;
            }
            catch (e) {
                if (this.inTransaction && onErrorRollback)
                    await this._execute('ROLLBACK TO ' + this._onErrorSavePoint + ';');
                throw e;
            }
        });
    }
    async startTransaction() {
        if (!this.inTransaction)
            await this.execute('BEGIN');
    }
    async savepoint(name) {
        if (!(name && name.match(/^[a-zA-Z]\w+$/)))
            throw new Error(`Invalid savepoint "${name}`);
        await this.execute('BEGIN; SAVEPOINT ' + name);
    }
    async commit() {
        if (this.inTransaction)
            await this.execute('COMMIT');
    }
    async rollback() {
        if (this.inTransaction)
            await this.execute('ROLLBACK');
    }
    async rollbackToSavepoint(name) {
        if (!(name && name.match(/^[a-zA-Z]\w+$/)))
            throw new Error(`Invalid savepoint "${name}`);
        await this.execute('ROLLBACK TO SAVEPOINT ' + name, { autoCommit: false });
    }
    async releaseSavepoint(name) {
        if (!(name && name.match(/^[a-zA-Z]\w+$/)))
            throw new Error(`Invalid savepoint "${name}`);
        await this.execute('RELEASE SAVEPOINT ' + name, { autoCommit: false });
    }
    ref() {
        this._refCount++;
        debug('[%s] ref %d', this.processID, this._refCount);
    }
    unref() {
        this._refCount--;
        debug('[%s] unref %d', this.processID, this._refCount);
        return !this._refCount;
    }
    assertConnected() {
        if (this.state === definitions_1.ConnectionState.CLOSING)
            throw new Error('Connection is closing');
        if (this.state === definitions_1.ConnectionState.CLOSED)
            throw new Error('Connection closed');
    }
    async _execute(sql, options, cb) {
        this.ref();
        try {
            debug('[%s] execute | %s', this.processID, sql);
            const startTime = Date.now();
            const result = {
                totalCommands: 0,
                totalTime: 0,
                results: [],
            };
            const opts = options || {};
            this.socket.sendQueryMessage(sql);
            let currentStart = Date.now();
            let parsers;
            let current = { command: undefined };
            let fields;
            const typeMap = opts.typeMap || DataTypeMap_1.GlobalTypeMap;
            return await this.socket.capture(async (code, msg, done) => {
                switch (code) {
                    case protocol_1.Protocol.BackendMessageCode.NoticeResponse:
                    case protocol_1.Protocol.BackendMessageCode.CopyInResponse:
                    case protocol_1.Protocol.BackendMessageCode.CopyOutResponse:
                    case protocol_1.Protocol.BackendMessageCode.EmptyQueryResponse:
                        break;
                    case protocol_1.Protocol.BackendMessageCode.RowDescription:
                        fields = msg.fields;
                        parsers = (0, common_1.getParsers)(typeMap, fields);
                        current.fields = (0, common_1.wrapRowDescription)(typeMap, fields, DataFormat.text);
                        current.rows = [];
                        break;
                    case protocol_1.Protocol.BackendMessageCode.DataRow:
                        let row = msg.columns.map((x) => x.toString('utf8'));
                        (0, common_1.parseRow)(parsers, row, opts);
                        if (opts.objectRows && current.fields)
                            row = (0, common_1.convertRowToObject)(current.fields, row);
                        if (cb)
                            cb('row', row);
                        current.rows = current.rows || [];
                        current.rows.push(row);
                        break;
                    case protocol_1.Protocol.BackendMessageCode.CommandComplete:
                        // Ignore BEGIN command that we added to sql
                        current.command = msg.command;
                        if (current.command === 'DELETE' ||
                            current.command === 'INSERT' ||
                            current.command === 'UPDATE')
                            current.rowsAffected = msg.rowCount;
                        current.executeTime = Date.now() - currentStart;
                        if (current.rows)
                            current.rowType = opts.objectRows && current.fields ? 'object' : 'array';
                        result.results.push(current);
                        if (cb)
                            cb('command-complete', current);
                        current = { command: undefined };
                        currentStart = Date.now();
                        break;
                    case protocol_1.Protocol.BackendMessageCode.ReadyForQuery:
                        this.transactionStatus = msg.status;
                        result.totalTime = Date.now() - startTime;
                        // Ignore COMMIT command that we added to sql
                        result.totalCommands = result.results.length;
                        done(undefined, result);
                }
            });
        }
        finally {
            this.unref();
        }
    }
    _onError(err) {
        if (this.socket.state !== definitions_1.ConnectionState.READY)
            return;
        debug('[%s] error | %s', this.processID, err.message);
        this.emit('error', err);
    }
}
exports.IntlConnection = IntlConnection;
