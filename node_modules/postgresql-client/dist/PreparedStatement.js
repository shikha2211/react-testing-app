"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreparedStatement = void 0;
const definitions_1 = require("./definitions");
const SafeEventEmitter_1 = require("./SafeEventEmitter");
const protocol_1 = require("./protocol/protocol");
const Cursor_1 = require("./Cursor");
const Portal_1 = require("./Portal");
const common_1 = require("./common");
const DataTypeMap_1 = require("./DataTypeMap");
const putil_varhelpers_1 = require("putil-varhelpers");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('pgc:statement');
let statementCounter = 0;
let portalCounter = 0;
class PreparedStatement extends SafeEventEmitter_1.SafeEventEmitter {
    constructor(connection, sql, paramTypes) {
        super();
        this._sql = '';
        this._name = '';
        this._refCount = 0;
        this._connection = connection;
        this._name = 'S_' + (++statementCounter);
        this._sql = sql;
        this._paramTypes = paramTypes;
        this._onErrorSavePoint = 'SP_' + (Math.round(Math.random() * 100000000));
    }
    static async prepare(connection, sql, options) {
        const intoCon = (0, common_1.getIntlConnection)(connection);
        intoCon.assertConnected();
        const socket = intoCon.socket;
        const statement = new PreparedStatement(connection, sql, options === null || options === void 0 ? void 0 : options.paramTypes);
        await intoCon.statementQueue.enqueue(async () => {
            intoCon.ref();
            try {
                socket.sendParseMessage({
                    statement: statement.name,
                    sql: statement.sql,
                    paramTypes: statement.paramTypes
                });
                socket.sendFlushMessage();
                try {
                    await socket.capture(async (code, msg, done) => {
                        switch (code) {
                            case protocol_1.Protocol.BackendMessageCode.NoticeResponse:
                                break;
                            case protocol_1.Protocol.BackendMessageCode.ParseComplete:
                                done();
                                break;
                            default:
                                done(new Error(`Server returned unexpected response message (0x${code.toString(16)})`));
                        }
                    });
                }
                finally {
                    socket.sendSyncMessage();
                    await socket.capture(async (code, msg, done) => {
                        switch (code) {
                            case protocol_1.Protocol.BackendMessageCode.NoticeResponse:
                                break;
                            case protocol_1.Protocol.BackendMessageCode.ReadyForQuery:
                                done();
                                break;
                            default:
                                done(new Error(`Server returned unexpected response message (0x${code.toString(16)})`));
                        }
                    });
                }
                debug('[%s] prepared | %s', statement.name, sql);
            }
            finally {
                intoCon.unref();
            }
        });
        statement._refCount = 1;
        return statement;
    }
    get connection() {
        return this._connection;
    }
    get name() {
        return this._name;
    }
    get sql() {
        return this._sql;
    }
    get paramTypes() {
        return this._paramTypes;
    }
    async execute(options = {}) {
        debug('[%s] execute', this.name);
        const intlCon = (0, common_1.getIntlConnection)(this.connection);
        const transactionCommand = this.sql.match(/^(\bBEGIN\b|\bCOMMIT\b|\bROLLBACK|SAVEPOINT|RELEASE\b)/i);
        let beginFirst = false;
        let commitLast = false;
        if (!transactionCommand) {
            if (!intlCon.inTransaction &&
                ((options === null || options === void 0 ? void 0 : options.autoCommit) != null ? options === null || options === void 0 ? void 0 : options.autoCommit : intlCon.config.autoCommit) === false) {
                beginFirst = true;
            }
            if (intlCon.inTransaction && (options === null || options === void 0 ? void 0 : options.autoCommit))
                commitLast = true;
        }
        if (beginFirst)
            await intlCon.execute('BEGIN');
        const onErrorRollback = !transactionCommand &&
            ((options === null || options === void 0 ? void 0 : options.onErrorRollback) != null ? options.onErrorRollback :
                (0, putil_varhelpers_1.coerceToBoolean)(intlCon.config.onErrorRollback, true));
        if (intlCon.inTransaction && onErrorRollback)
            await intlCon.execute('SAVEPOINT ' + this._onErrorSavePoint);
        try {
            const result = await intlCon.statementQueue.enqueue(() => this._execute(options));
            if (commitLast)
                await intlCon.execute('COMMIT');
            else if (intlCon.inTransaction && onErrorRollback)
                await intlCon.execute('RELEASE ' + this._onErrorSavePoint + ';');
            return result;
        }
        catch (e) {
            if (intlCon.inTransaction && onErrorRollback)
                await intlCon.execute('ROLLBACK TO ' + this._onErrorSavePoint + ';');
            throw e;
        }
    }
    async close() {
        --this._refCount;
        debug('[%s] close | refCount = %d', this.name, this._refCount);
        if (this._refCount > 0)
            return;
        const intoCon = (0, common_1.getIntlConnection)(this.connection);
        await intoCon.statementQueue.enqueue(() => this._close());
    }
    async cancel() {
        throw new Error('Not implemented yet');
    }
    async _execute(options = {}) {
        let portal;
        const intlCon = (0, common_1.getIntlConnection)(this.connection);
        debug('[%s] _execute', this.name);
        intlCon.ref();
        try {
            const result = { command: undefined };
            const startTime = Date.now();
            const t = Date.now();
            // Create portal
            const portalName = 'P_' + (++portalCounter);
            portal = new Portal_1.Portal(this, portalName);
            await portal.bind(options.params, options);
            const fields = await portal.retrieveFields();
            const typeMap = options.typeMap || DataTypeMap_1.GlobalTypeMap;
            let parsers;
            let resultFields;
            if (fields) {
                parsers = (0, common_1.getParsers)(typeMap, fields);
                resultFields = (0, common_1.wrapRowDescription)(typeMap, fields, options.columnFormat || definitions_1.DEFAULT_COLUMN_FORMAT);
                result.fields = resultFields;
                result.rowType = options.objectRows ? 'object' : 'array';
                if (options.cursor) {
                    result.cursor = new Cursor_1.Cursor(this, portal, resultFields, parsers, options);
                    this._refCount++;
                    portal = undefined;
                    return result;
                }
            }
            const executeResult = await portal.execute(options.fetchCount);
            result.executeTime = Date.now() - t;
            if (executeResult.command)
                result.command = executeResult.command;
            if (resultFields && parsers && executeResult.rows) {
                if (!result.command)
                    result.command = 'SELECT';
                const rows = result.rows = executeResult.rows;
                const l = rows.length;
                let row;
                for (let i = 0; i < l; i++) {
                    row = rows[i];
                    (0, common_1.parseRow)(parsers, row, options);
                    if (options.objectRows) {
                        rows[i] = (0, common_1.convertRowToObject)(resultFields, row);
                    }
                }
            }
            if (result.command === 'DELETE' ||
                result.command === 'INSERT' ||
                result.command === 'UPDATE')
                result.rowsAffected = executeResult.rowCount;
            result.executeTime = Date.now() - startTime;
            return result;
        }
        finally {
            intlCon.unref();
            if (portal)
                await portal.close();
        }
    }
    async _close() {
        if (--this._refCount > 0)
            return;
        const intoCon = (0, common_1.getIntlConnection)(this.connection);
        intoCon.ref();
        try {
            const socket = intoCon.socket;
            socket.sendCloseMessage({ type: 'S', name: this.name });
            socket.sendSyncMessage();
            await socket.capture(async (code, msg, done) => {
                switch (code) {
                    case protocol_1.Protocol.BackendMessageCode.NoticeResponse:
                        this.emit('notice', msg);
                        break;
                    case protocol_1.Protocol.BackendMessageCode.CloseComplete:
                        break;
                    case protocol_1.Protocol.BackendMessageCode.ReadyForQuery:
                        intoCon.transactionStatus = msg.status;
                        done();
                        break;
                    default:
                        done(new Error(`Server returned unexpected response message (0x${code.toString(16)})`));
                }
            });
        }
        finally {
            intoCon.unref();
        }
        debug('[%s] closed');
        this.emit('close');
    }
}
exports.PreparedStatement = PreparedStatement;
