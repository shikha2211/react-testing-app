"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapRowDescription = exports.getIntlConnection = exports.convertRowToObject = exports.parseRow = exports.getParsers = void 0;
const protocol_1 = require("./protocol/protocol");
const parse_array_1 = require("./util/parse-array");
const decode_binaryarray_1 = require("./util/decode-binaryarray");
var DataFormat = protocol_1.Protocol.DataFormat;
const definitions_1 = require("./definitions");
const DefaultColumnParser = (v) => v;
function getParsers(typeMap, fields) {
    const parsers = new Array(fields.length);
    const l = fields.length;
    let f;
    let i;
    for (i = 0; i < l; i++) {
        f = fields[i];
        const dataTypeReg = typeMap.get(f.dataTypeId);
        if (dataTypeReg) {
            const isArray = !!dataTypeReg.elementsOID;
            if (f.format === DataFormat.binary) {
                const decode = dataTypeReg.parseBinary;
                if (decode) {
                    parsers[i] = !isArray ? decode :
                        (v, options) => (0, decode_binaryarray_1.decodeBinaryArray)(v, decode, options);
                }
            }
            else if (f.format === DataFormat.text) {
                const parse = dataTypeReg.parseText;
                if (parse) {
                    parsers[i] = !isArray ? parse :
                        (v, options) => (0, parse_array_1.parsePostgresArray)(v, {
                            transform: (x => parse(x, options)),
                            separator: dataTypeReg.arraySeparator,
                        });
                }
            }
        }
        parsers[i] = parsers[i] || DefaultColumnParser;
    }
    return parsers;
}
exports.getParsers = getParsers;
function parseRow(parsers, row, options) {
    const l = row.length;
    let i;
    for (i = 0; i < l; i++) {
        row[i] = row[i] == null ? null :
            parsers[i].call(undefined, row[i], options);
    }
}
exports.parseRow = parseRow;
function convertRowToObject(fields, row) {
    const out = {};
    const l = row.length;
    let i;
    for (i = 0; i < l; i++) {
        out[fields[i].fieldName] = row[i];
    }
    return out;
}
exports.convertRowToObject = convertRowToObject;
function getIntlConnection(connection) {
    return connection._intlCon;
}
exports.getIntlConnection = getIntlConnection;
function wrapRowDescription(typeMap, fields, columnFormat) {
    return fields.map((f, idx) => {
        const cf = Array.isArray(columnFormat) ? columnFormat[idx] : columnFormat;
        const x = {
            fieldName: f.fieldName,
            tableId: f.tableId,
            columnId: f.columnId,
            dataTypeId: f.dataTypeId,
            dataTypeName: definitions_1.DataTypeNames[f.dataTypeId] || '',
            jsType: cf === DataFormat.binary ? 'Buffer' : 'string'
        };
        x.isArray = x.dataTypeName.startsWith('_');
        if (x.isArray) {
            x.elementDataTypeName = x.dataTypeName.substring(1);
            for (const oid of Object.keys(definitions_1.DataTypeNames)) {
                if (definitions_1.DataTypeNames[oid] === x.elementDataTypeName)
                    x.elementDataTypeId = parseInt(oid, 10);
            }
        }
        if (f.fixedSize && f.fixedSize > 0)
            x.fixedSize = f.fixedSize;
        if (f.modifier && f.modifier > 0)
            x.modifier = f.modifier;
        const reg = typeMap.get(x.dataTypeId);
        if (reg) {
            x.jsType = reg.jsType;
        }
        return x;
    });
}
exports.wrapRowDescription = wrapRowDescription;
