import { SafeEventEmitter } from './SafeEventEmitter';
import { ConnectionConfiguration, ConnectionState, StatementPrepareOptions, QueryOptions, QueryResult, ScriptExecuteOptions, ScriptResult, Maybe } from './definitions';
import type { Pool } from './Pool';
import { PreparedStatement } from './PreparedStatement';
import { IntlConnection } from './IntlConnection';
import { DatabaseError } from './protocol/DatabaseError';
export declare class Connection extends SafeEventEmitter {
    private readonly _pool?;
    private readonly _intlCon;
    private _closing;
    constructor(pool: Pool, intlCon: IntlConnection);
    constructor(config?: ConnectionConfiguration | string | IntlConnection);
    /**
     * Returns configuration object
     */
    get config(): ConnectionConfiguration;
    /**
     * Returns true if connection is in a transaction
     */
    get inTransaction(): boolean;
    /**
     * Returns current state of the connection
     */
    get state(): ConnectionState;
    /**
     * Returns processId of current session
     */
    get processID(): Maybe<number>;
    /**
     * Returns information parameters for current session
     */
    get sessionParameters(): Record<string, string>;
    /**
     * Returns secret key of current session
     */
    get secretKey(): Maybe<number>;
    /**
     * Connects to the server
     */
    connect(): Promise<void>;
    /**
     * Closes connection. You can define how long time the connection will
     * wait for active queries before terminating the connection.
     * On the end of the given time, it forces to close the socket and than emits `terminate` event.
     *
     * @param terminateWait {number} - Determines how long the connection will wait for active queries before terminating.
     */
    close(terminateWait?: number): Promise<void>;
    /**
     * Executes single or multiple SQL scripts using Simple Query protocol.
     *
     * @param sql {string} - SQL script that will be executed
     * @param options {ScriptExecuteOptions} - Execute options
     */
    execute(sql: string, options?: ScriptExecuteOptions): Promise<ScriptResult>;
    query(sql: string, options?: QueryOptions): Promise<QueryResult>;
    /**
     * Creates a PreparedStatement instance
     * @param sql {string} - SQL script that will be executed
     * @param options {StatementPrepareOptions} - Options
     */
    prepare(sql: string, options?: StatementPrepareOptions): Promise<PreparedStatement>;
    /**
     * Starts a transaction
     */
    startTransaction(): Promise<void>;
    /**
     * Commits current transaction
     */
    commit(): Promise<void>;
    /**
     * Rolls back current transaction
     */
    rollback(): Promise<void>;
    /**
     * Starts transaction and creates a savepoint
     * @param name {string} - Name of the savepoint
     */
    savepoint(name: string): Promise<void>;
    /**
     * Rolls back current transaction to given savepoint
     * @param name {string} - Name of the savepoint
     */
    rollbackToSavepoint(name: string): Promise<void>;
    /**
     * Releases savepoint
     * @param name {string} - Name of the savepoint
     */
    releaseSavepoint(name: string): Promise<void>;
    protected _close(): Promise<void>;
    protected _handleError(err: DatabaseError, script: string): DatabaseError;
}
