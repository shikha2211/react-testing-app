/// <reference types="node" />
import tls from "tls";
import type { Cursor } from './Cursor';
import type { SmartBuffer } from './protocol/SmartBuffer';
import { Protocol } from './protocol/protocol';
import type { PoolConfiguration as LPoolConfiguration } from 'lightning-pool';
import { DataTypeMap } from './DataTypeMap';
import { BindParam } from './BindParam';
import DataFormat = Protocol.DataFormat;
export declare type OID = number;
export declare type Maybe<T> = T | undefined;
export declare type Nullable<T> = T | null;
export { DataFormat };
export declare type Row = any;
export declare type Callback = (err?: Error, value?: any) => void;
export declare const DEFAULT_COLUMN_FORMAT = DataFormat.binary;
export interface DatabaseConnectionParams {
    host?: string;
    port?: number;
    user?: string;
    password?: string | (() => string | Promise<string>);
    database?: string;
    applicationName?: string;
    ssl?: tls.ConnectionOptions;
    timezone?: string;
    schema?: string;
    connectTimeoutMs?: number;
    /**
     * Specifies weather execute query in auto-commit mode
     * @default false
     */
    autoCommit?: boolean;
    /**
     * When on, if a statement in a transaction block generates an error,
     * the error is ignored and the transaction continues.
     * When off (the default), a statement in a transaction block that generates an error aborts the entire transaction
     * @default true
     */
    onErrorRollback?: boolean;
}
export interface SocketOptions {
    keepAlive?: boolean;
}
export declare type ConnectionConfiguration = DatabaseConnectionParams & SocketOptions;
export interface PoolConfiguration extends ConnectionConfiguration, LPoolConfiguration {
}
export declare enum ConnectionState {
    CLOSED = 0,
    CONNECTING = 1,
    AUTHORIZING = 3,
    READY = 2,
    CLOSING = 10
}
export interface DataMappingOptions {
    /**
     * If true UTC time will be used for date decoding, else system time offset will be used
     * @default false
     */
    utcDates?: boolean;
    fetchAsString?: OID[];
}
export interface ScriptExecuteOptions extends DataMappingOptions {
    /**
     * Specifies weather execute query in auto-commit mode
     * @default true
     */
    autoCommit?: boolean;
    /**
     * Specifies if rows will be fetched as <FieldName, Value> pair objects or array of values
     * @default false
     */
    objectRows?: boolean;
    /**
     * Data type map instance
     * @default GlobalTypeMap
     */
    typeMap?: DataTypeMap;
    /**
     * When on, if a statement in a transaction block generates an error,
     * the error is ignored and the transaction continues.
     * When off (the default), a statement in a transaction block that generates an error aborts the entire transaction
     * @default true
     */
    onErrorRollback?: boolean;
}
export interface StatementPrepareOptions {
    /**
     * Specifies data type for each parameter
     */
    paramTypes?: OID[];
    /**
     * Data type map instance
     * @default GlobalTypeMap
     */
    typeMap?: DataTypeMap;
}
export interface QueryOptions extends DataMappingOptions {
    /**
     * Specifies weather execute query in auto-commit mode
     * @default true
     */
    autoCommit?: boolean;
    /**
     * Specifies if rows will be fetched as <FieldName, Value> pair objects or array of values
     * @default false
     */
    objectRows?: boolean;
    /**
     * Data type map instance
     * @default GlobalTypeMap
     */
    typeMap?: DataTypeMap;
    /**
     * If true, returns Cursor instance instead of rows
     */
    cursor?: boolean;
    /**
     * Query execution parameters
     */
    params?: (BindParam | any)[];
    /**
     * Specifies transfer format (binary or text) for each column
     * @default DataFormat.binary
     */
    columnFormat?: DataFormat | DataFormat[];
    /**
     * Specifies how many rows will be fetched. For Cursor, this value specifies how many rows will be fetched in a batch
     * @default 100
     */
    fetchCount?: number;
    /**
     * When on, if a statement in a transaction block generates an error,
     * the error is ignored and the transaction continues.
     * When off (the default), a statement in a transaction block that generates an error aborts the entire transaction
     * @default true
     */
    onErrorRollback?: boolean;
}
export interface CommandResult {
    /**
     * Name of the command (INSERT, SELECT, UPDATE, etc.)
     */
    command?: string;
    /**
     * Contains information about fields in column order
     */
    fields?: FieldInfo[];
    /**
     * Contains array of row data
     */
    rows?: any[];
    /**
     * Contains row type
     */
    rowType?: 'array' | 'object';
    /**
     * Time elapsed to execute command
     */
    executeTime?: number;
    /**
     * How many rows affected
     */
    rowsAffected?: number;
}
export interface ScriptResult {
    /**
     * Array of command result for each sql command in the script
     */
    results: CommandResult[];
    /**
     * Command count in the script
     */
    totalCommands: number;
    /**
     * Total execution time
     */
    totalTime: number;
}
export interface FieldInfo {
    /**
     * Name of the field
     */
    fieldName: string;
    /**
     * OID of the table
     */
    tableId?: number;
    /**
     * OID of the column
     */
    columnId?: number;
    /**
     * OID of the data type
     */
    dataTypeId: number;
    /**
     * Name of the data type
     */
    dataTypeName: string;
    /**
     * OID of the elements data type if field is an array
     */
    elementDataTypeId?: number;
    /**
     * Name of the elements data type if field is an array
     */
    elementDataTypeName?: string;
    /**
     * JS type name that data type mapped
     */
    jsType: string;
    /**
     * Data length if data type has a fixed size
     */
    fixedSize?: number;
    /**
     * Modifier of the data type
     */
    modifier?: number;
    /**
     * Whether the data type is an array
     */
    isArray?: boolean;
}
export interface QueryResult extends CommandResult {
    /**
     * Cursor instance
     */
    cursor?: Cursor;
}
export declare type DecodeBinaryFunction = (buf: Buffer, options: DataMappingOptions) => any;
export declare type EncodeBinaryFunction = (buf: SmartBuffer, v: any, options: DataMappingOptions) => void;
export declare type ParseTextFunction = (v: any, options: DataMappingOptions) => any;
export declare type EncodeTextFunction = (v: any, options: DataMappingOptions) => string;
export declare type AnyParseFunction = ParseTextFunction | DecodeBinaryFunction;
export interface DataType {
    oid: OID;
    name: string;
    elementsOID?: OID;
    jsType: string;
    arraySeparator?: string;
    isType: (v: any) => boolean;
    parseBinary: DecodeBinaryFunction;
    parseText: ParseTextFunction;
    encodeBinary?: EncodeBinaryFunction;
    encodeText?: EncodeTextFunction;
}
export interface Point {
    x: number;
    y: number;
}
export interface Circle {
    x: number;
    y: number;
    r: number;
}
export interface Rectangle {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
}
export declare const DataTypeOIDs: {
    bool: number;
    bytea: number;
    char: number;
    name: number;
    int8: number;
    int2: number;
    int2vector: number;
    int4: number;
    regproc: number;
    text: number;
    oid: number;
    tid: number;
    xid: number;
    cid: number;
    oidvector: number;
    json: number;
    xml: number;
    point: number;
    lseg: number;
    path: number;
    box: number;
    polygon: number;
    line: number;
    cidr: number;
    float4: number;
    float8: number;
    unknown: number;
    circle: number;
    macaddr8: number;
    money: number;
    macaddr: number;
    inet: number;
    bpchar: number;
    varchar: number;
    date: number;
    time: number;
    timestamp: number;
    timestamptz: number;
    interval: number;
    timetz: number;
    bit: number;
    varbit: number;
    numeric: number;
    refcursor: number;
    regprocedure: number;
    regoper: number;
    regoperator: number;
    regclass: number;
    regtype: number;
    record: number;
    cstring: number;
    any: number;
    anyarray: number;
    void: number;
    trigger: number;
    language_handler: number;
    internal: number;
    anyelement: number;
    anynonarray: number;
    uuid: number;
    jsonb: number;
    anyrange: number;
    int4range: number;
    numrange: number;
    tsrange: number;
    rstzrange: number;
    daterange: number;
    int8range: number;
    _xml: number;
    _json: number;
    _xid8: number;
    _line: number;
    _cidr: number;
    _circle: number;
    _macaddr8: number;
    _money: number;
    _bool: number;
    _bytea: number;
    _char: number;
    _name: number;
    _int2: number;
    _int2vector: number;
    _int4: number;
    _regproc: number;
    _text: number;
    _xid: number;
    _cid: number;
    _oidvector: number;
    _bpchar: number;
    _varchar: number;
    _int8: number;
    _point: number;
    _lseg: number;
    _path: number;
    _box: number;
    _float4: number;
    _float8: number;
    _polygon: number;
    _oid: number;
    _macaddr: number;
    _inet: number;
    _timestamp: number;
    _date: number;
    _time: number;
    _timestamptz: number;
    _interval: number;
    _numeric: number;
    _cstring: number;
    _timetz: number;
    _bit: number;
    _varbit: number;
    _uuid: number;
    _jsonb: number;
};
export declare const DataTypeNames: {
    [x: number]: string;
};
